# scripts/validate_network_model.py
"""
Script de validation pratique pour le mod√®le d'analyse r√©seau CICIDS2017
Usage: python scripts/validate_network_model.py [--full] [--interface eth0]
"""
import os
import sys
import argparse
import time
import json
from pathlib import Path
from datetime import datetime

# Ajouter le r√©pertoire racine au path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

def check_dependencies():
    """V√©rifie que toutes les d√©pendances sont install√©es"""
    print("üîç V√©rification des d√©pendances...")
    
    required_packages = {
        'numpy': 'numpy',
        'pandas': 'pandas', 
        'sklearn': 'scikit-learn',
        'torch': 'torch',
        'xgboost': 'xgboost'
    }
    
    optional_packages = {
        'pyshark': 'pyshark',
        'scapy': 'scapy'
    }
    
    missing_required = []
    missing_optional = []
    
    for package, pip_name in required_packages.items():
        try:
            __import__(package)
            print(f"‚úÖ {package}")
        except ImportError:
            missing_required.append(pip_name)
            print(f"‚ùå {package} - REQUIS")
    
    for package, pip_name in optional_packages.items():
        try:
            __import__(package)
            print(f"‚úÖ {package}")
        except ImportError:
            missing_optional.append(pip_name)
            print(f"‚ö†Ô∏è {package} - optionnel")
    
    if missing_required:
        print(f"\n‚ùå Packages requis manquants: {', '.join(missing_required)}")
        print(f"Installer avec: pip install {' '.join(missing_required)}")
        return False
    
    if missing_optional:
        print(f"\n‚ö†Ô∏è Packages optionnels manquants: {', '.join(missing_optional)}")
        print(f"Pour la capture r√©seau: pip install {' '.join(missing_optional)}")
        print("Mode fallback sera utilis√© sans ces packages")
    
    return True

def test_model_loading():
    """Test le chargement du mod√®le"""
    print("\nüìä Test de chargement du mod√®le...")
    
    try:
        from agents.cybersecurity_agent.custom_model_loaders import NetworkAnalyzerXGBoost
        
        print("üîÑ Chargement du mod√®le XGBoost...")
        model = NetworkAnalyzerXGBoost()
        
        # Test de pr√©diction basique
        test_inputs = [
            "normal web traffic",
            "ddos flood attack", 
            "port scan reconnaissance"
        ]
        
        print("üß™ Test des pr√©dictions...")
        for test_input in test_inputs:
            result = model.predict([test_input])
            print(f"   Input: '{test_input}' ‚Üí {result[0] if result else 'Erreur'}")
        
        print("‚úÖ Mod√®le charg√© et fonctionnel!")
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur chargement mod√®le: {e}")
        return False

def test_traffic_collection(interface="any", duration=10):
    """Test la collecte de trafic"""
    print(f"\nüì° Test de collecte de trafic (interface: {interface}, dur√©e: {duration}s)...")
    
    try:
        from agents.cybersecurity_agent.traffic_collector import RealTimeTrafficCollector
        
        collector = RealTimeTrafficCollector(interface=interface)
        print(f"üîç M√©thode de capture: {collector.capture_method}")
        
        print(f"üìà D√©marrage capture ({duration}s)...")
        print("üí° G√©n√©rez du trafic r√©seau maintenant (navigation web, ping, etc.)")
        
        features_df = collector.start_capture(duration=duration, max_packets=100)
        
        if not features_df.empty:
            print(f"‚úÖ {len(features_df)} flows captur√©s")
            print(f"üìã Features extraites: {len(features_df.columns)} colonnes")
            
            # Afficher quelques features
            if len(features_df) > 0:
                first_flow = features_df.iloc[0]
                print("üîç Exemple de features extraites:")
                print(f"   Flow Duration: {first_flow.get('Flow Duration', 0):.2f}")
                print(f"   Total Fwd Packets: {first_flow.get('Total Fwd Packets', 0)}")
                print(f"   Total Backward Packets: {first_flow.get('Total Backward Packets', 0)}")
            
            return True
        else:
            print("‚ö†Ô∏è Aucun trafic captur√©")
            return False
            
    except Exception as e:
        print(f"‚ùå Erreur collecte trafic: {e}")
        return False

def test_end_to_end_analysis(interface="any"):
    """Test complet d'analyse end-to-end"""
    print(f"\nüéØ Test d'analyse compl√®te...")
    
    try:
        from agents.cybersecurity_agent.traffic_collector import RealTimeTrafficCollector
        from agents.cybersecurity_agent.custom_model_loaders import NetworkAnalyzerXGBoost
        
        # Charger le mod√®le
        model = NetworkAnalyzerXGBoost()
        collector = RealTimeTrafficCollector(interface=interface)
        
        print("üì° Capture de trafic pour analyse (15s)...")
        features_df = collector.start_capture(duration=15, max_packets=50)
        
        if features_df.empty:
            print("‚ö†Ô∏è Aucun trafic √† analyser")
            return False
        
        print(f"üß† Analyse de {len(features_df)} flows avec le mod√®le...")
        
        results = []
        for index, row in features_df.iterrows():
            # Convertir les features en description textuelle (simplifi√©)
            features_text = f"flow with {row.get('Total Fwd Packets', 0)} forward packets and {row.get('Total Backward Packets', 0)} backward packets"
            
            try:
                prediction = model.predict([features_text])
                if prediction:
                    results.append(prediction[0])
                else:
                    results.append({'label': 'ERROR', 'score': 0})
            except Exception as e:
                print(f"   ‚ö†Ô∏è Erreur analyse flow {index}: {e}")
                results.append({'label': 'ERROR', 'score': 0})
        
        # Statistiques des r√©sultats
        labels = [r.get('label', 'UNKNOWN') for r in results]
        label_counts = {}
        for label in labels:
            label_counts[label] = label_counts.get(label, 0) + 1
        
        print("üìä R√©sultats d'analyse:")
        for label, count in label_counts.items():
            percentage = (count / len(results)) * 100
            print(f"   {label}: {count} flows ({percentage:.1f}%)")
        
        # V√©rifier si des attaques ont √©t√© d√©tect√©es
        attack_labels = [l for l in labels if l not in ['NORMAL', 'ERROR', 'UNKNOWN']]
        if attack_labels:
            print(f"üö® Attaques potentielles d√©tect√©es: {set(attack_labels)}")
        else:
            print("‚úÖ Aucune attaque d√©tect√©e - trafic semble normal")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur analyse end-to-end: {e}")
        return False

def run_full_validation():
    """Lance la validation compl√®te avec le syst√®me int√©gr√©"""
    print("\nüöÄ VALIDATION COMPL√àTE DU MOD√àLE")
    print("="*50)
    
    try:
        from agents.cybersecurity_agent.traffic_collector import NetworkModelValidator
        
        validator = NetworkModelValidator()
        
        print("‚è≥ Ex√©cution de la suite de validation compl√®te...")
        print("üìù Cela peut prendre quelques minutes...")
        
        results = validator.run_validation_suite()
        
        # G√©n√©rer et afficher le rapport
        report = validator.generate_validation_report(results)
        print("\n" + report)
        
        # Sauvegarder le rapport
        report_file = f"data/validation_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        os.makedirs(os.path.dirname(report_file), exist_ok=True)
        
        with open(report_file, 'w') as f:
            f.write(report)
        
        print(f"\nüíæ Rapport sauvegard√©: {report_file}")
        
        return results['overall_success']
        
    except Exception as e:
        print(f"‚ùå Erreur validation compl√®te: {e}")
        return False

def simulate_attacks():
    """Simule des attaques pour tester la d√©tection"""
    print("\nüé≠ Simulation d'attaques pour test...")
    
    attack_simulations = [
        {
            'name': 'Port Scan',
            'command': 'nmap -sS -F 127.0.0.1',
            'description': 'Scan de ports TCP sur localhost'
        },
        {
            'name': 'SYN Flood (l√©ger)',
            'command': 'hping3 -S -p 80 -c 50 -i u100 127.0.0.1',
            'description': 'Attaque SYN flood l√©g√®re'
        },
        {
            'name': 'Ping Flood (l√©ger)',
            'command': 'ping -f -c 100 127.0.0.1',
            'description': 'Flood de pings'
        }
    ]
    
    print("üìã Attaques disponibles pour simulation:")
    for i, attack in enumerate(attack_simulations, 1):
        print(f"   {i}. {attack['name']}: {attack['description']}")
        print(f"      Commande: {attack['command']}")
    
    print("\n‚ö†Ô∏è ATTENTION: Ces simulations sont √† des fins de test uniquement!")
    print("üí° Lancez ces commandes manuellement dans un autre terminal pendant la capture")
    print("üîß Assurez-vous d'avoir les outils install√©s (nmap, hping3)")
    
    choice = input("\nVoulez-vous des instructions d√©taill√©es? (y/N): ")
    
    if choice.lower() == 'y':
        print("\nüìñ INSTRUCTIONS D√âTAILL√âES:")
        print("1. Ouvrez un nouveau terminal")
        print("2. Pendant que le script capture le trafic, lancez une des commandes ci-dessus")
        print("3. Exemple complet:")
        print("   Terminal 1: python scripts/validate_network_model.py --test-traffic")
        print("   Terminal 2: nmap -sS -F 127.0.0.1")
        print("4. Observez les r√©sultats de d√©tection")

def check_network_interfaces():
    """Affiche les interfaces r√©seau disponibles"""
    print("\nüåê Interfaces r√©seau disponibles:")
    
    try:
        import psutil
        
        interfaces = psutil.net_if_addrs()
        for interface, addresses in interfaces.items():
            status = "UP" if interface in psutil.net_if_stats() and psutil.net_if_stats()[interface].isup else "DOWN"
            print(f"   üì° {interface}: {status}")
            
            for addr in addresses:
                if addr.family == 2:  # IPv4
                    print(f"      IPv4: {addr.address}")
    
    except ImportError:
        print("‚ö†Ô∏è psutil non disponible - utiliser 'ip addr' ou 'ifconfig'")
        
        # Fallback avec commandes syst√®me
        try:
            import subprocess
            result = subprocess.run(['ip', 'addr'], capture_output=True, text=True)
            if result.returncode == 0:
                lines = result.stdout.split('\n')
                for line in lines:
                    if ': ' in line and 'inet ' not in line:
                        parts = line.split(': ')
                        if len(parts) > 1:
                            interface = parts[1].split('@')[0]
                            print(f"   üì° {interface}")
        except:
            print("‚ö†Ô∏è Utilisez 'ip addr' ou 'ifconfig' pour voir les interfaces")

def create_requirements_file():
    """Cr√©e un fichier requirements.txt pour les d√©pendances"""
    requirements = [
        "numpy>=1.21.0",
        "pandas>=1.3.0", 
        "scikit-learn>=1.0.0",
        "torch>=1.9.0",
        "xgboost>=1.5.0",
        "transformers>=4.15.0",
        "huggingface-hub>=0.11.0",
        "# Optional - pour capture r√©seau",
        "pyshark>=0.4.5",
        "scapy>=2.4.5",
        "psutil>=5.8.0"
    ]
    
    req_file = "requirements_network_validation.txt"
    
    with open(req_file, 'w') as f:
        f.write('\n'.join(requirements))
    
    print(f"üìù Fichier cr√©√©: {req_file}")
    print(f"üîß Installation: pip install -r {req_file}")

def main():
    parser = argparse.ArgumentParser(description="Validation du mod√®le d'analyse r√©seau CICIDS2017")
    
    parser.add_argument('--full', action='store_true', 
                       help='Lance la validation compl√®te')
    parser.add_argument('--interface', default='any',
                       help='Interface r√©seau √† utiliser (d√©faut: any)')
    parser.add_argument('--duration', type=int, default=15,
                       help='Dur√©e de capture en secondes (d√©faut: 15)')
    parser.add_argument('--check-deps', action='store_true',
                       help='V√©rifie seulement les d√©pendances')
    parser.add_argument('--test-model', action='store_true',
                       help='Test seulement le chargement du mod√®le')
    parser.add_argument('--test-traffic', action='store_true',
                       help='Test seulement la capture de trafic')
    parser.add_argument('--simulate-attacks', action='store_true',
                       help='Affiche les instructions pour simuler des attaques')
    parser.add_argument('--interfaces', action='store_true',
                       help='Affiche les interfaces r√©seau disponibles')
    parser.add_argument('--create-requirements', action='store_true',
                       help='Cr√©e un fichier requirements.txt')
    
    args = parser.parse_args()
    
    print("üöÄ VALIDATION MOD√àLE R√âSEAU CICIDS2017")
    print("="*50)
    print(f"üìÖ Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"üñ•Ô∏è Interface: {args.interface}")
    print("")
    
    success = True
    
    # Actions sp√©cifiques
    if args.create_requirements:
        create_requirements_file()
        return
    
    if args.interfaces:
        check_network_interfaces()
        return
    
    if args.simulate_attacks:
        simulate_attacks()
        return
    
    # V√©rification des d√©pendances (toujours)
    if not check_dependencies():
        print("\n‚ùå Impossible de continuer sans les d√©pendances requises")
        print("üí° Utilisez --create-requirements pour g√©n√©rer le fichier d'installation")
        return 1
    
    # Tests sp√©cifiques
    if args.check_deps:
        print("\n‚úÖ Toutes les d√©pendances sont install√©es!")
        return 0
    
    if args.test_model:
        success = test_model_loading()
    
    elif args.test_traffic:
        success = test_traffic_collection(args.interface, args.duration)
    
    elif args.full:
        success = run_full_validation()
    
    else:
        # Test rapide par d√©faut
        print("üî¨ VALIDATION RAPIDE")
        print("-" * 30)
        
        # 1. Test mod√®le
        if not test_model_loading():
            success = False
        
        # 2. Test capture
        if success and not test_traffic_collection(args.interface, args.duration):
            success = False
        
        # 3. Test end-to-end
        if success and not test_end_to_end_analysis(args.interface):
            success = False
        
        print("\n" + "="*50)
        if success:
            print("‚úÖ VALIDATION RAPIDE R√âUSSIE!")
            print("üí° Pour une validation compl√®te: --full")
            print("üé≠ Pour tester avec des attaques: --simulate-attacks")
        else:
            print("‚ùå VALIDATION √âCHOU√âE!")
            print("üîß V√©rifiez les erreurs ci-dessus")
    
    print("\nüìñ Autres options utiles:")
    print("   --interfaces     : Voir les interfaces r√©seau")
    print("   --test-model     : Tester seulement le mod√®le")
    print("   --test-traffic   : Tester seulement la capture")
    print("   --simulate-attacks : Instructions simulation d'attaques")
    print("   --create-requirements : Cr√©er requirements.txt")
    
    return 0 if success else 1

if __name__ == "__main__":
    try:
        exit_code = main()
        sys.exit(exit_code)
    except KeyboardInterrupt:
        print("\n\n‚èπÔ∏è Arr√™t demand√© par l'utilisateur")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Erreur inattendue: {e}")
        print("üêõ Veuillez reporter ce bug avec les d√©tails ci-dessus")
        sys.exit(1)